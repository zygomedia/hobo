<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hobo book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="hobo is a Rust frontend framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hobo book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hobo"><a class="header" href="#hobo">hobo</a></h1>
<p><a href="https://crates.io/crates/hobo"><img alt="Crate Info" src="https://img.shields.io/crates/v/hobo.svg"/></a>
<a href="https://docs.rs/hobo"><img alt="API Docs" src="https://img.shields.io/badge/docs.rs-hobo-yellow"/></a></p>
<p><strong>hobo</strong> is an opinionated, batteries-included Rust frontend framework. Works on <strong>stable Rust</strong>.<br />
<strong>STILL WIP</strong> although used in production by <a href="https://zygomedia.com">Zygo Media</a>.<br />
<a href="https://zygomedia.github.io/hobo">Check out the Book</a>!</p>
<h3 id="notable-features"><a class="header" href="#notable-features">Notable features:</a></h3>
<ul>
<li><strong>no virtual DOM</strong> - HTML elements are just components added to entities and can be accessed directly via <code>web_sys::HtmlElement</code></li>
<li>no Model-View-Update (aka Elm architecture) - state management is manual, usually via Entity-Component relations</li>
<li>no HTML macros - just Rust functions</li>
<li>built-in styling, kind of like CSS-in-JS except it's just Rust functions</li>
<li><strong>minimal macros/DSLs</strong> - just Rust functions, the only notable exception is CSS selectors, which are pretty close to base CSS</li>
<li><strong>reactivity support</strong> via <a href="https://github.com/Pauan/rust-signals">futures-signals</a></li>
<li>Entity-Component based approach allowing flexible state propagation and cohesion between elements without coupling or a need for global store or state</li>
</ul>
<h3 id="sneak-peek"><a class="header" href="#sneak-peek">Sneak peek:</a></h3>
<pre><code class="language-rust noplaypen">pub use hobo::{
    prelude::*,
    create as e,
    signals::signal::{Mutable, SignalExt}
};

fn counter() -&gt; impl hobo::AsElement {
    let counter = Mutable::new(0);

    e::div()
        .class((
            css::display::flex,
            css::flex_direction::column,
            css::width::px(400),
        ))
        .child(e::div()
            .text_signal(counter.signal_ref(|value| {
                format!("Counter value is: {value}")
            }))
        )
        .child(e::button()
            .text("increment")
            .on_click(move |_| *counter.lock_mut() += 1)
        )
}</code></pre>
<p>TODO:</p>
<h3 id="comparions-to-other-rust-in-browser-frameworks"><a class="header" href="#comparions-to-other-rust-in-browser-frameworks">Comparions to other Rust-in-browser frameworks</a></h3>
<ul>
<li>yew</li>
<li>leptos</li>
<li>seed</li>
<li>etc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Here's a basic counter component:</p>
<pre><code class="language-rust noplaypen">use hobo::{
    prelude::*,
    create as e,
    signal::Mutable,
}

// &lt;div class="s-f4d1763947b5e1ff"&gt;
//   &lt;div&gt;Counter value is: 0&lt;/div&gt;
//   &lt;button&gt;increment&lt;/button&gt;
//   &lt;button&gt;decrement&lt;/button&gt;
// &lt;/div&gt;

fn counter() -&gt; impl hobo::AsElement {
    let counter_value = Mutable::new(0_i32);

    e::div()
        .class((
            // enum-like properties can also be set like `css::Display::Flex`
            css::display::flex,
            css::width::px(400),
            // #AA0000FF or #AA0000 or #A00 in normal css
            css::background_color::rgb(0xAA_00_00),
            css::align_items::center,
            css::justify_content::space_between,
        ))
        .child(e::div()
            .text_signal(counter_value.signal_ref(|value|
                format!("Counter value is: {value}"))
            )
        )
        .component(counter_value)
        .with(move |&amp;counter_div| counter_div
            .child(e::button()
                .class(css::style!(
                    // .&amp; is replaced with "current" class name, similar to SASS
                    // or styled-components
                    .&amp; {
                        // shortcut for padding-left and padding-right
                        css::padding_horizontal::px(16),
                        css::background_color::rgba(css::colors::PALEVIOLETRED),
                    }

                    .&amp;:hover {
                        css::background_color::rgba(css::colors::GREEN),
                    }
                ))
                .text("increment")
                .on_click(move |_| {
                    *counter_div.get_cmp::&lt;Mutable&lt;i32&gt;&gt;().lock_mut() += 1;
                })
            )
            .add_child(e::button() // same as .child but non-chaining
                // since this style is identical to the one above it -
                // the class will be reused to avoid copypasting -
                // the button generating code can be moved into
                // a function or maybe just the code that defines the style
                .class(css::style!(
                    .&amp; {
                        css::padding_horizontal::px(16),
                        css::background_color::rgba(css::colors::PALEVIOLETRED),
                    }

                    .&amp;:hover {
                        css::background_color::rgba(css::colors::GREEN),
                    }
                ))
                .text("decrement")
                .on_click(move |_| {
                    *counter_div.get_cmp::&lt;Mutable&lt;i32&gt;&gt;().lock_mut() -= 1;
                })
            )
        )
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>This chapter outlines core types, traits and styling facilities that <code>hobo</code> employs.</p>
<p>Some note on terms used:</p>
<ul>
<li><strong>Entity</strong>: a (usually) copyable id, that has components associated with it</li>
<li><strong>Element</strong>: not to be confused with HTML elements, an Entity that has HTML or SVG components (which represent HTML elements) associated with it and so can have children, class, attributes, etc</li>
<li><strong>Component</strong>: any kind of data that may be associated with an Entity</li>
<li><strong>Mutable</strong>: not to be confused with Rust's notion of mutability, a type from <a href="https://crates.io/crates/futures-signals">futures_signals</a> that can be used to produce signals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-components-and-resources"><a class="header" href="#entities-components-and-resources">Entities, Components (and Resources)</a></h1>
<p>The backbone of the framework is the Entity-Component approach of associating data. <strong>Entities</strong> are just incrementing <code>u64</code>s under the hood, they carry no data.</p>
<p><strong>Elements</strong> are no different in this regard, the only difference is that <strong>Elements</strong> have a compile time promise that these entities have <code>web_sys::Node</code>, <code>web_sys::Element</code>, <code>web_sys::EventTarget</code> and one of <code>web_sys::HtmlElement</code> or <code>web_sys::SvgElement</code> attached to them. As a consequence, these <strong>Entities</strong> can get styled, get attributes and compose into DOM.</p>
<p><strong>Resources</strong> are same as <strong>Components</strong> but they are accessible globally, they aren't associated with any entity. Only one instance of a type of <strong>Resource</strong> can exist at any time, in this way they are similar to singletons from other programming languages. Internally, they are represented as regular <strong>Components</strong> associated with special <strong>Entity</strong> with id 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hobocreate"><a class="header" href="#hobocreate"><code>hobo::create</code></a></h1>
<p><a href="https://docs.rs/hobo/latest/hobo/create/index.html">This module</a> has a <code>snake_case</code> function which returns a corresponding <code>PascalCase</code> concrete type that implements <strong>AsElement</strong> for each supported basic HTML and SVG element.</p>
<pre><code class="language-rust noplaypen">let some_div: hobo::create::Div = hobo::create::div();</code></pre>
<p><strong>Element</strong> has methods that aren't available on regular entities.</p>
<h2 id="hoboaselement-and-hoboasentity"><a class="header" href="#hoboaselement-and-hoboasentity"><code>hobo::AsElement</code> and <code>hobo::AsEntity</code></a></h2>
<p>Sometimes it's useful to have custom types so you can have some special capabilities on your <strong>Entities</strong> or <strong>Elements</strong>.</p>
<pre><code class="language-rust noplaypen">#[derive(hobo::AsElement, Clone, Copy /* etc */)]
struct Checkbox(hobo::create::Div);

// just an example of why you might want to do this
impl Checkbox {
	fn is_checked(&amp;self) -&gt; bool {
		*self.get_cmp_or_default::&lt;bool&gt;()
	}

	fn set_checked(&amp;self, checked: bool) {
		*self.get_cmp_mut_or_default::&lt;bool&gt;() = checked;
	}

	// probably etc methods
}</code></pre>
<p>The <code>hobo::AsElement</code> derive macro expects either a tuple struct or a regular struct where the <strong>Entity</strong> field is named <code>element</code> e.g.</p>
<pre><code class="language-rust noplaypen">#[derive(hobo::AsElement, Clone, Copy /* etc */)]
struct CustomSelect {
	element: hobo::create::Select,
	// etc
}</code></pre>
<h2 id="element-and-type-erasure"><a class="header" href="#element-and-type-erasure"><code>Element</code> and type erasure</a></h2>
<p>It's often useful to mix different types of <strong>Elements</strong>, for example:</p>
<pre><code class="language-rust noplaypen">fn content() -&gt; impl hobo::AsElement {
	match tab {
		Tab::Main =&gt; main_page(), // hobo::create::Div
		Tab::Blogpost =&gt; article(), // hobo::create::Article
		// etc
	}
}</code></pre>
<p>This won't compile, but the distinction between types in this case isn't useful. So we can erase the concrete types and get the general <code>Element</code>:</p>
<pre><code class="language-rust noplaypen">fn content() -&gt; impl hobo::AsElement {
	match tab {
		Tab::Main =&gt; main_page().as_element(), // hobo::Element
		Tab::Blogpost =&gt; article().as_element(), // hobo::Element
		// etc
	}
}</code></pre>
<p>If you have a regular <strong>Entity</strong> or something that at least implements <code>hobo::AsEntity</code> - you can recover <strong>Element</strong> capabilities by just wrapping it in an <code>Element</code>:</p>
<pre><code class="language-rust noplaypen">let elem = hobo::Element(some_entity);</code></pre>
<p>This pattern is often useful when using queries to find elements, as queries often return entities (more on them in <a href="basic-concepts/../state/queries.html">queries</a>)</p>
<pre><code class="language-rust noplaypen">let (_, entity) = hobo::find_ond::&lt;With&lt;ComponentFoo&gt;, Entity&gt;();
// We know that this entity is an Input element we've made,
// but we need it's type to be an Input, not Entity,
// to e.g. access it's value via the get/set_value methods
let input_element = hobo::create::Input(entity);
let input_value = input_element.value();</code></pre>
<p>One can think of it almost as casting - we're fetching an entity which we, as the writer, know is an Input - however, we need to "cast" this Entity to an Input type in order to access Input capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="children-and-parent"><a class="header" href="#children-and-parent">Children and Parent</a></h1>
<p>Hierarchical DOM relations in <code>hobo</code> are maintained through regular <strong>Components</strong> - <a href="https://docs.rs/hobo/latest/hobo/hierarchy/struct.Children.html">hobo::Children</a> and <a href="https://docs.rs/hobo/latest/hobo/hierarchy/struct.Parent.html">hobo::Parent</a>.</p>
<p>Usually you won't have to care about it since <code>.add_child()</code> (and the like) and <code>.remove()</code> already take care of updating <code>Children</code> and <code>Parent</code> components of affected entities.</p>
<p><code>hobo::Children</code> is just a <code>Vec</code> of <code>hobo::Entity</code>, <code>hobo::Parent</code> is a newtype wrapper over <code>hobo::Entity</code> as well. If you have an <strong>Element</strong> and you want to operate on all (or some) of its children - it's as simple as:</p>
<pre><code class="language-rust noplaypen">let children = foo.get_cmp::&lt;hobo::Children&gt;()
    .iter()
    .map(|entity| hobo::Element(entity));

for child in children {
    child.set_text("hello from hobo!");
}</code></pre>
<p>It is possible to detach a child from its parent to reattach it to a different <strong>Element</strong> later, but it's not as simple as removing <code>hobo::Parent</code> and fixing up <code>hobo::Children</code> of the parent entity since the DOM has to be modified as well. A convenient method exists however:</p>
<pre><code class="language-rust noplaypen">// this removes parent and fixes children component in parent as well
some_child.leave_parent();
new_parent.add_child(some_child);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removing-and-replacing-elements"><a class="header" href="#removing-and-replacing-elements">Removing and replacing elements</a></h1>
<p>Removing an <strong>Element</strong> (or an <strong>Entity</strong>) is as simple as calling <code>.remove()</code>. The method will recursively remove all entities in <code>hobo::Children</code> of the entity to be removed as well. All components that have been added to entities that are being removed are also removed and dropped.</p>
<p>It is possible to replace an <strong>Element</strong> inplace, fixing up the <code>hobo::Children</code> in parent entity as well. This, however, replaces it with a new <strong>Entity</strong> so if a copy is held somewhere - it won't be valid anymore, so take care.</p>
<pre><code class="language-rust noplaypen">let new_element = hobo::create::div();
old_element.replace_with(new_element);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dom-events-and-eventhandlercallback"><a class="header" href="#dom-events-and-eventhandlercallback">DOM Events and EventHandlerCallback</a></h1>
<p><strong>Elements</strong> have methods that allow reacting to DOM Events. All of these methods are <code>snake_case</code> in the form of <code>.on_&lt;name&gt;</code> e.g. <code>.on_click</code> or <code>.on_touch_start</code>. Not all possible events are supported currently, but adding new ones is very easy - PRs welcome!</p>
<pre><code class="language-rust noplaypen">element
    .on_click(move |_| { // the argument here is web_sys::MouseEvent
        element.set_text("I am clicked!");
    })</code></pre>
<p>These methods operate by means of, unsurprisingly, adding or modifying a <strong>Component</strong> on the element. The callback itself gets wrapped in <a href="https://docs.rs/hobo/latest/hobo/dom_events/struct.EventHandler.html">hobo::dom_events::EventHandler</a>, which will unsubscribe from DOM when dropped. A <strong>Component</strong> with a <code>Vec&lt;EventHandler&gt;</code> is created unless it already exists, then the just created <code>EventHandler</code> is just pushed into it.</p>
<p>It's possible to manage subscribing/unsubscribing manually by calling the functions on raw <code>web_sys::HtmlElement</code>s. For example, when you're doing some kind of a slider and you want some logic in <code>on_mouse_move</code> even if the mouse leaves the element:</p>
<pre><code class="language-rust noplaypen">element
    .on_mouse_down(move |_| {
        // "drag" start
    })
    .component((
        web_sys::window().unwrap().on_mouse_move(move |e| {
            // if dragging, run some dragging logic even once mouse leaves the element
        }),
        web_sys::window().unwrap().on_mouse_up(move |e| {
            // "drag" stop
        }),
    ))</code></pre>
<p>Note that the <code>.on_mouse_move()</code> and <code>.on_mouse_up()</code> aren't actually <code>web_sys::window()</code>'s functions - these are extension methods, provided by <code>hobo</code> via <a href="https://docs.rs/hobo/latest/hobo/dom_events/trait.RawDomEvents.html">hobo::dom_events::RawDomEvents</a> extension trait for any <a href="https://docs.rs/web-sys/latest/web_sys/struct.EventTarget.html">web_sys::EventTarget</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-and-storage"><a class="header" href="#borrowing-and-storage">Borrowing and Storage</a></h1>
<p>Components for entities are stored in a simple map - <code>HashMap&lt;Entity, Component&gt;</code> (see, <a href="https://docs.rs/hobo/latest/hobo/storage/struct.Storage.html">hobo::storage::Storage</a>).</p>
<p>(This also makes searching for components via <code>hobo::find_one</code> <em>very</em> cheap, as it's just a single <code>u64</code> hashmap lookup)</p>
<p>Rust's ownership rules ensure that a mutable borrow is exclusive, which means that we cannot have mutable references to components while immutable ones exists (or vice-versa).
Here's an example of how this affects hobo:</p>
<pre><code class="language-rust noplaypen">// src\example_file.rs

mod example_module {
    pub use hobo::{prelude::*, create as e};

    struct Foo;

    pub fn test() -&gt; impl hobo::AsElement {
        e::div()
            .component(Foo)
            .with(|&amp;element| {
                // Ok
                let foo1 = element.get_cmp::&lt;Foo&gt;();
                // Still ok
                let foo2 = element.get_cmp::&lt;Foo&gt;();
                // Panic!
                let foo3 = element.get_cmp_mut::&lt;Foo&gt;();
            })
    }
}</code></pre>
<p>This, of course, also applies to queries/find/etc.</p>
<p>This can be a bit tricky to debug in Wasm, which is why when compiling in debug mode, hobo will display the following helpful message in the browser's console if a borrow-related runtime panic is encountered:</p>
<pre><code>panicked at ''already borrowed': Trying to mutably borrow `example_module::Foo`    
storage at `src\example_file.rs:16:50` while other borrows to it already exist:

(mut) src\example_file.rs:16:50
      src\example_flib.rs:14:50
      src\example_flib.rs:12:50
</code></pre>
<p>This will list <strong>only</strong> the currently active borrows, as well as the mutable one, descending in order of access.</p>
<p>(Every type we store as a component will have it's own storage, so it's fine to mutably borrow storages of different types.)</p>
<p>As an example of where this could arise as an issue, imagine the following situation:</p>
<p>We want to replace an element with a new one, using some data we stored in it.</p>
<pre><code class="language-rust noplaypen">struct SomeData {
    big_data: u64,
};

pub fn update_element(old_element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;();

    let new_element = process_data_and_return_div(some_data);
    
    // Runtime panic!
    old_element.replace_with(new_element);
}</code></pre>
<p>This will panic at runtime - this is because when we delete the old element (via replace) we need to mutably borrow the storage to all of it's components, in order to delete them too.
However, we are already holding a reference to one of the components.</p>
<p>The way to circumvent this would be similar to how one would for any other ownership issue:</p>
<p>You can drop the guard, ensuring that no references conflict:</p>
<pre><code class="language-rust noplaypen">pub fn update_element(old_element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;();

    let new_element = process_data_and_return_div(some_data);
    
    drop(some_data);

    old_element.replace_with(new_element);
}</code></pre>
<p>Or, you can clone the value:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone)]
struct SomeData {
    big_data: u64,
};

pub fn update_element(element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;().clone();

    let new_element = process_data_and_return_div(&amp;some_data);
    
    old_element.replace_with(new_element);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-facilities"><a class="header" href="#styling-facilities">Styling facilities</a></h1>
<p>Most <strong>Elements</strong> will be styled with either <code>.class()</code> or <code>.style()</code> functions, where either <code>css::style!</code> or a property tuple will be used.</p>
<ul>
<li><code>.style()</code> and <code>.set_style()</code> use the <code>style</code> attribute, which can only take a bunch of properties without any selectors, so a property tuple is used.</li>
<li><code>.class()</code>, <code>.set_class()</code> and <code>tagged</code> or <code>typed</code> variants use the <code>class</code> attribute:</li>
</ul>
<p>For example, here's a style:</p>
<pre><code class="language-rust noplaypen">hobo::create::div()
    .class(css::style!(
        .&amp; {
            css::height::px(393),
            css::display::flex,
            css::align_items::center,
            css::position::relative,
        }

        .&amp; &gt; svg {
            css::width::px(12),
            css::height::pct(100),
            css::cursor::pointer,
            css::flex_shrink::val(0),
            css::user_select::none,
        }

        .&amp; &gt; :not(:nth_child(0, 1)) { // nth_child will convert to An+B syntax
            css::z_index::val(200),
        }

        .&amp; &gt; div:not(:nth_child(0, 1)) {
            css::width::pct(17.5),
            css::height::pct(100),
            css::display::flex,
            css::align_items::center,
        }

        // doubling up on the class name increases specificity
        .&amp;.&amp; &gt; :nth_child(0, 5) { 
            css::width::pct(30),
        }

        .&amp; &gt; *:nth_child(0, 3) &gt; img,
        .&amp; &gt; *:nth_child(0, 4) &gt; img,
        .&amp; &gt; svg:last_child {
            css::transform::translate_x(50.),
        }

        .&amp; &gt;&gt; img { // this is same as `.&amp; img` selector in css
            css::height::pct(100),
        }
    ))</code></pre>
<p>Property tuple example:</p>
<pre><code class="language-rust noplaypen">    hobo::create::div()
        .style((
            // Shortcut for same width and height
            css::size::px(12),
            css::display::flex,
        ))</code></pre>
<p>If only a single property is used, one can omit the tuple:</p>
<pre><code class="language-rust noplaypen">    hobo::create::div()
        .class(css::display::flex)</code></pre>
<blockquote>
<p><strong>Chaining vs non-chaining syntax:</strong> <code>.style()</code> is the chaining syntax, <code>.set_style()</code> is the non-chaining alternative. Similarly, <code>.class()</code> and <code>.set_class()</code>. More about chaining vs non-chaining syntax in <a href="./building-the-dom.html#chaining-vs-non-chaining-syntax">Building the DOM</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selector"><a class="header" href="#selector">Selector</a></h1>
<p>hobo selectors mirror CSS selectors with minor changes, most notably:</p>
<ul>
<li>descendant selectors like <code>div a</code> become <code>div &gt;&gt; a</code> because Rust doesn't have semantic whitespaces.
<ul>
<li>selectors like <code>div.active</code> work mostly the same (except have to be written like <code>div.("active")</code> or <code>div .("active")</code>)</li>
</ul>
</li>
<li>ids have to be written like <code>#("foo-1234")</code></li>
<li>pseudo-classes use <code>_</code> instead of <code>-</code> and must always use single colon syntax, e.g. <code>:active</code> or <code>:last_child</code>
<ul>
<li>there's an escape hatch in <code>:raw("-webkit-prop".to_string())</code> for browser-specific or other weird things</li>
</ul>
</li>
<li>pseudo-elements use <code>_</code> instead of <code>-</code> and must always use double colon syntax, e.g. <code>::after</code> or <code>::first_line</code></li>
</ul>
<p>There are also several additions:</p>
<ul>
<li><code>.&amp;</code> will be replaced at runtime with the name of a class, which will be generated from the rules in the style it belongs to
<ul>
<li>in other words, it's similar to <code>&amp;</code> in SASS or <code>styled-components</code></li>
</ul>
</li>
<li><code>.[T]</code> where <code>T</code> is some marker type will be replaced with the generated classname for the type <code>T</code> so you could select based on custom marker type.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct ButtonMarker;

e::div()
    .class(css::style!(
        .&amp; &gt;&gt; .[ButtonMarker] {
            css::cursor::pointer,
        }
    ))
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text("button 1")
    )
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text("button 2")
    )</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property"><a class="header" href="#property">Property</a></h1>
<p>Most CSS properties will be expressed as tuples of anything that implements <code>hobo::css::AppendProperty</code>, which includes:</p>
<ul>
<li><code>css::Property</code> such as created by the <code>css::&lt;prop&gt;()</code> family of functions (e.g. <code>css::width()</code>, <code>css::flex_shrink()</code>, etc)</li>
<li><code>Vec&lt;css::Property&gt;</code></li>
<li><code>()</code></li>
<li><code>&amp;'static str</code> and <code>String</code> as escape hatches</li>
<li><code>FnOnce(&amp;mut Vec&lt;Property&gt;)</code> for rare complex logic</li>
<li>Other tuples of things that implement <code>hobo::css::AppendProperty</code></li>
</ul>
<p>Conditional property inclusion could be expressed as different <code>Vec&lt;css::Property&gt;</code> where one is empty, e.g.</p>
<pre><code class="language-rust noplaypen">(
    css::display::flex,
    if active {
        css::properties![css::background_color::rgba(0x00_00_FF_FF)]
    } else {
        css::properties![css::color::gray(0xA8)]
    },
	"--moz-user-input:none;".to_string(),
)</code></pre>
<p>(we have to use <code>css::properties!</code> instead of <code>vec!</code> because all properties are of different types)</p>
<p>Or alternatively, by leveraging <code>FnOnce</code></p>
<pre><code class="language-rust noplaypen">(
    css::display::flex,
    move |props| if active { props.push(css::background_color::rgba(0x00_00_FF_FF)); },
	"--moz-user-input:none;".to_string(),
)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rules"><a class="header" href="#-rules">@-rules</a></h1>
<p>Right now hobo only supports <code>@font-face</code> and a subset of <code>@media</code></p>
<h1 id="font-face"><a class="header" href="#font-face"><code>@font-face</code></a></h1>
<p>The block following <code>@font-face</code> is passed as initialization for <code>css::font_face::FontFace</code>. Check out the <a href="https://docs.rs/hobo_css/latest/hobo_css/font_face/struct.FontFace.html">docs</a>.<br />
It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>@font-face {
    src: vec![("https://fonts.gstatic.com/.../....woff2".into(), Some(Format::Woff2))],
    font_family: "Encode Sans".into(),
    font_weight: (Weight::Number(400), None),
}
<span class="boring">}</span></code></pre></pre>
<h1 id="media"><a class="header" href="#media"><code>@media</code></a></h1>
<p>The syntax is different to <code>@media</code> rules in css:</p>
<ul>
<li>specifying media type is not optional</li>
<li><code>!</code> instead of <code>not</code></li>
<li><code>CamelCase</code> instead of <code>kebab-case</code></li>
<li><code>&amp;&amp;</code> instead of <code>and</code></li>
<li>no grouping rules in <code>not</code> clauses</li>
</ul>
<p>So these two would be equivalent:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>@media All &amp;&amp; MaxWidth(css::unit!(1023 px)) {
    html {
        css::background_color::rgb(0xFF_00_00),
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-css">@media all and (max-width: 1023px) {
    html {
        background-color: #FF0000;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colors"><a class="header" href="#colors">Colors</a></h1>
<p>Color property macros like <code>css::color</code> and <code>css::fill</code> and the like have shorthands for full-alpha RGB colors as well as grayscale.</p>
<pre><code class="language-rust noplaypen">css::color::rgb(0xFF_00_00), // same as css::color::rgba(0xFF_00_00_FF) or #F00 in css
css::color::gray(0xAD), // same as css::color::rgba(0xAD_AD_AD_FF) or #ADADAD in css</code></pre>
<p>CSS named colors also can be used</p>
<pre><code class="language-rust noplaypen">css::color::rgba(css::colors::PALEVIOLETRED),
css::color::rgba(css::colors::GREEN),</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="every-way-to-make-a-class"><a class="header" href="#every-way-to-make-a-class">Every way to make a class</a></h1>
<p>Apart from regular <code>.class()</code>/<code>.set_class()</code> options there's several others:</p>
<ul>
<li><code>.mark::&lt;T&gt;()</code>/<code>.unmark::&lt;T&gt;()</code> - can generate classes from any type for targeted selection.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct ButtonMarker;

e::div()
    .class(css::style!(
        .&amp; &gt;&gt; .[ButtonMarker] {
            css::cursor::pointer,
        }
    ))
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text("button 1")
    )
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text("button 2")
    )</code></pre>
<p>Every call to <code>.class()</code>/<code>.set_class()</code> will append a new class - if you want to override an existing one, there are two options:</p>
<ul>
<li><code>.set_class_typed::&lt;Type&gt;(style)</code> - generates a tag from a <code>Type</code>. This is usually the preferred method, in the rare case that you need to override classes.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct Flexible;

e::div()
    .class((css::display::flex, css::background_color::rgba(css::colors::RED)))
    .class_typed::&lt;Flexible&gt;((
        css::flex_direction::row,
        css::width::px(100),
    ))
    .with(|&amp;element| element.add_on_click(move |_| {
        element
            .set_class_typed::&lt;Flexible&gt;((
                css::flex_direction::column,
                css::height::px(100),
            ))
    }))</code></pre>
<ul>
<li><code>.set_class_tagged::&lt;Tag: Hash&gt;(tag, style)</code> - Similar to <code>.set_class_tagged</code>, but uses an instance of a type rather than <code>Type</code>. The regular <code>.class()</code> method uses this internally with just an incrementing <code>u64</code> for a tag.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

e::div()
    .class(css::display::flex)
    .class_tagged("Flexible", (
        css::flex_direction::row,
        css::width::px(100),
    ))
    .on_click(|&amp;element| {
        element
            .set_class_tagged("Flexible", (
                css::flex_direction::column,
                css::height::px(100),
            ))
    })</code></pre>
<p>Prefer using this over <code>.set_class_typed</code> if your tag is computed at runtime.</p>
<ul>
<li>signals - you can have your classes be set reactively, in response to some changes in a <code>Mutable</code>. This is the preferred method for anything reactive, such as switching between themes:</li>
</ul>
<pre><code class="language-rust noplaypen">enum Theme {
    Light,
    Dark,
}

let theme = Mutable::new(Theme::Light);

e::div()
    .class_typed_signal::&lt;Theme, _, _&gt;(theme.signal().map(|theme| {
        match theme {
            Theme::Light =&gt; css::background_color::rgba(css::colors::WHITE),
            Theme::Dark =&gt; css::background_colo::rgba(css::colors::BLACK),
        }
    }))
    .component(theme)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-state-and-relations-with-components"><a class="header" href="#managing-state-and-relations-with-components">Managing state and relations with <strong>Components</strong></a></h1>
<p>The next few chapters will outline how hobo deals with shared state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Queries allow finding individual <strong>Entities</strong> or collections of <strong>Entities</strong>. Best shown by examples:</p>
<pre><code class="language-rust noplaypen">struct Foo {
    // some fields
}

// find the first (presumably only) element with some component Foo
let (_, element) = hobo::find_one::&lt;(With&lt;Foo&gt;, Element)&gt;();
element.set_text("This entity has Foo");</code></pre>
<pre><code class="language-rust noplaypen">struct Frobnicator {
    num_fraculations: u32,
    // other fields
}

// find all entities with a Frobnicator component and mutate it
// perhaps as a result of some combined transformation
for frobnicator in hobo::find::&lt;&amp;mut Frobnicator&gt;() {
    frobnicator.num_fraculations += 1;
}</code></pre>
<p>Queries are tuples of <code>&amp; T</code>, <code>&amp;mut T</code> or <code>With&lt;T&gt;</code> where <code>T</code> is some component or, as special cases, <code>Entity</code> or <code>Element</code>. The result of <code>hobo::find</code> (or <code>hobo::find_one</code>) are tuples where each member is what was requested by the query (<code>With&lt;T&gt;</code> will always return <code>true</code> in its position because any entity that doesn't have <code>T</code> won't be included in the output).</p>
<p>Queries are also often useful to establish relations with distant <strong>Elements</strong>. For example, an <strong>Element</strong> in one part of the DOM can get an <strong>Element</strong> from a completely unrelated part of the DOM.</p>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct SettingsData {
    speed: f32,
}

let settings_container = e::div()
    // etc
    .component(SettingsData { speed: 0.35 })

// -- snip --

let unrelated_display = e::div()
    //etc
    .text(hobo::find_one::&lt;&amp;SettingsData&gt;().speed.to_string())</code></pre>
<p><code>hobo</code> doesn't do anything clever with these queries and just dutifully filters by component, so for best performance - pass the most disciminating components early and <code>Entity</code> or <code>Element</code> last.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>Hobo has some useful reactivity facilities. The core of this is <code>futures_signals::signal::Mutable</code>, from which signals are created, check the <a href="https://docs.rs/futures-signals/0.3">futures-signals</a> documentation for details on how to do that.</p>
<p>Hobo re-exports <code>futures_signals</code> as <code>hobo::signals</code>.</p>
<ul>
<li><code>text_signal</code>/<code>set_text_signal</code> - calls <code>set_text</code> whenever the signal value changes</li>
<li><code>child_signal</code>/<code>add_child_signal</code> - initially creates an empty <code>div</code>, then calls <code>.replace_with</code> every time the signal value changes</li>
<li><code>class_signal</code>/<code>set_class_signal</code> and <code>class_typed_signal</code>/<code>set_class_typed_signal</code> and <code>class_tagged_signal</code>/<code>set_class_tagged_signal</code> - calls <code>set_class_tagged</code> whenever the signal value changes
<ul>
<li>will always replace the first class so take care</li>
</ul>
</li>
<li><code>attr_signal</code>/<code>set_attr_signal</code> and <code>bool_attr_signal</code>/<code>set_bool_attr_signal</code> - calls <code>set_attr</code> whenever the signal value changes</li>
<li><code>style_signal</code>/<code>set_style_signal</code> - calls <code>set_style</code> whenever the signal value changes</li>
<li><code>mark_signal</code> - calls <code>mark</code>/<code>unmark</code> whenever the signal value changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-dom"><a class="header" href="#building-the-dom">Building the DOM</a></h1>
<p>Assembling elements is usually done via function chaining, but every function has a non-chained variant for use in loops or in case ownership gets tricky.</p>
<p>Here's an example of a somewhat involved element:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use hobo::{prelude::*, create as e};

#[derive(hobo::Element)]
pub struct Input {
    element: e::Div,
    pub input: e::Input,
}

impl Input {
    pub fn new(caption_text: &amp;str, svg: Option&lt;e::Svg&gt;) -&gt; Self {
        let input = e::input()
            // shortcut for .attr(web_str::r#type(), web_str::text())
            .type_text()
            .class((
                // some style
            ));

        let caption_text = e::div()
            .text(caption_text)
            .class((
                // some style
            ));

        let mut element = e::div()
            .class(css::style! {
                // some style
            })
            .child(input)
            .child(caption_text);

        if let Some(svg) = svg {
            element.add_child(
                svg.class((
                    // some style
                ))
            );
        }

        Self { element, input }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="children"><a class="header" href="#children"><code>.children()</code></a></h3>
<p>Same as <code>.child()</code> but can consume an <code>impl IntoIterator</code>, convenient when taking a <code>Vec&lt;T&gt;</code> as an argument in list-like element constructors.<br />
There is no <code>.children_signal()</code> but it could potentially exist - PRs welcome!</p>
<h3 id="chaining-vs-non-chaining-syntax"><a class="header" href="#chaining-vs-non-chaining-syntax">Chaining vs non-chaining syntax</a></h3>
<p>Most functions have a chaining syntax, handy when constructing the element, and also non-chaining syntax for use in loops or other contexts. The convention is <code>.&lt;foo&gt;</code> for chaining and <code>.add_&lt;foo&gt;</code> for non-chaining. This goes against the more common Rust convention of <code>.with_&lt;foo&gt;</code> being the chaining syntax, this is because most code will be simple elements constructed in bulk, so most of these calls will be chaining so a shorter name is preferred.</p>
<ul>
<li><code>.child()</code>/<code>.child_signal()</code> vs <code>.add_child()</code>/<code>.add_child_signal()</code></li>
<li><code>.children()</code> vs <code>.add_children()</code></li>
<li><code>.class()</code>/<code>.class_tagged()</code>/<code>.class_typed()</code>/<code>.class_signal()</code> vs <code>.set_class()</code>/<code>.set_class_tagged()</code>/<code>.set_class_typed()</code>/<code>.set_class_signal()</code></li>
<li><code>.style()</code>/<code>.style_signal()</code> vs <code>.set_style()</code>/<code>.set_style_signal()</code></li>
<li><code>.attr()</code>/<code>.bool_attr()</code>/<code>.attr_signal()</code>/<code>.bool_attr_signal()</code> vs <code>.set_attr()</code>/<code>.set_bool_attr()</code>/<code>.set_attr_signal()</code>/<code>.set_bool_attr_signal()</code></li>
<li><code>.&lt;event&gt;()</code> vs <code>.add_&lt;event&gt;()</code></li>
<li><code>.text()</code>/<code>.text_signal()</code> vs <code>.set_text()</code>/<code>.set_text_signal()</code></li>
<li><code>.component()</code> vs <code>.add_component()</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-utilities"><a class="header" href="#other-utilities">Other utilities</a></h1>
<p>This chapter outlines useful helpers for common tasks that didn't make it into the core.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web_str"><a class="header" href="#web_str">web_str</a></h1>
<p>The <code>web_str</code> module is just a bunch of commonly used interned strings. It includes all element names, all event names and a bunch of common attributes and values like <code>class</code>, <code>min</code>, <code>max</code>, <code>checked</code>, <code>href</code>, <code>readonly</code>, etc. If something is missing - PRs welcome!</p>
<p>To read more about what is string interning and why is it useful: <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/fn.intern.html">wasm-bindgen docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>There is a simple way to fire and respond to global events.</p>
<pre><code class="language-rust noplaypen">pub use hobo::{
    prelude::*,
    create as e,
};

struct MyEvent(u64);

fn make_foo() -&gt; impl hobo::AsElement {
    e::div()
        // etc children and styles
        .component(hobo::events::on(move |&amp;MyEvent(x)| {
            // do something with x
        }))
}

// -- snip --

hobo::events::fire(&amp;MyEvent(123));</code></pre>
<p>The subscribers are notified based on event type, so it's better to create new types for different events rather than fire an event with a string or an enum.</p>
<p>Using events, however, is discouraged. The "spooky action at a distance" effect, while often useful, can make the codebase very confusing. Prefer using signals to update the DOM and queries to get entities or components that should be updated.</p>
<p>The implementation in <code>hobo</code> isn't unique and there's many crates that implement something similar, but <code>hobo</code>'s implementation assumes single-threaded execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>This chapter outlines common idioms and patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>There is no stdout in the browser so the simplest way is to use the <a href="https://crates.io/crates/log">log</a> crate with <a href="https://crates.io/crates/wasm-logger">wasm-logger</a> and <a href="https://crates.io/crates/console_error_panic_hook">console_error_panic_hook</a> to see nicely formatted errors:</p>
<pre><code class="language-rust noplaypen">#[wasm_bindgen(start)]
pub fn main() {
    wasm_logger::init(wasm_logger::Config::default());
    console_error_panic_hook::set_once();

    // etc init and mounting of elements
    
    log::info!("it works!");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elements-that-change"><a class="header" href="#elements-that-change">Elements that change</a></h1>
<p>Since there's no VDOM, rebuilding the DOM is done manually by literally rebuilding the altered parts. It is on the developer to minimize this to maintain element focus, scroll position, performance, etc. The same goes for styling - any complex modification is best expressed as recreating the whole style.</p>
<p>However, most modifications can often be expressed with signals, with some child, style or text of an element just being a result of some computation based on one or multiple Mutables. With regards to styling in particular, most of the style is probably not going to change, with only minor changes based on something like theme.</p>
<pre><code class="language-rust noplaypen">.class((
    // a lot of different properties that never_change
))
.class_typed_signal::&lt;Theme, _, _&gt;(theme.signal().map(|theme| {
    match theme {
        Theme::Light =&gt; css::background_color::rgba(css::colors::WHITE),
        Theme::Dark =&gt; css::background_color::rgba(css::colors::BLACK),
    }
}))</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svgs"><a class="header" href="#svgs">SVGs</a></h1>
<p>There is a way to conveniently create inline SVGs without rewriting them manually with <code>hobo</code>'s syntax.</p>
<pre><code class="language-rust noplaypen">thread_local! {
    static LAST_ID: RefCell&lt;u64&gt; = RefCell::new(0);
}

fn get_svg_element(xml_node: &amp;roxmltree::Node, id: u64) -&gt; web_sys::SvgElement {
    let node: web_sys::SvgElement = wasm_bindgen::JsCast::unchecked_into(document().create_element_ns(Some(wasm_bindgen::intern("http://www.w3.org/2000/svg")), xml_node.tag_name().name()).unwrap());

    for attribute in xml_node.attributes() {
        // need to fixup ids to avoid id collisions in html if the same icon is used multiple times
        if attribute.name() == "id" {
            node.set_attribute(wasm_bindgen::intern(attribute.name()), &amp;format!("{}{id:x}", attribute.value())).unwrap();
        } else {
            let mut value = attribute.value().to_owned();
            // optimistic expectation that ids only used in url references
            if value.contains("url(#") {
                value = value.replace(')', &amp;format!("{id:x})"))
            }
            node.set_attribute(wasm_bindgen::intern(attribute.name()), &amp;value).unwrap();
        }
    }

    for child in xml_node.children().filter(roxmltree::Node::is_element) {
        node.append_child(&amp;get_svg_element(&amp;child, id)).unwrap();
    }

    node
}

macro_rules! svg {
    ($($name:ident =&gt; $address:expr),*$(,)*) =&gt; {$(
        #[must_use]
        pub fn $name() -&gt; e::Svg {
            let id = LAST_ID.with(move |last_id| {
                let mut last_id = last_id.borrow_mut();
                let id = *last_id;
                *last_id += 1;
                id
            });
            let element: web_sys::SvgElement = get_svg_element(&amp;roxmltree::Document::parse(include_str!($address)).unwrap().root_element(), id);
            e::Svg(hobo::create::svg_element(&amp;element))
        }
    )*};
}

svg![
    logo =&gt; r"../../public/img/icons/etc/logo.svg",
    discord =&gt; r"../../public/img/icons/shapes/discord.svg",
];</code></pre>
<p>This code makes some assumptions which might not be true for your SVGs, but the general idea is to convert source XML into <code>web_sys::XXX</code> elements. Similar approach can be used to include some HTML verbatim. A variant of this <code>svg!</code> macro is included in <a href="recipes/../hobo-plus.html">hobo-plus</a></p>
<h2 id="constructing-inline-svgs"><a class="header" href="#constructing-inline-svgs">Constructing inline SVGs</a></h2>
<p>Of course, if you need to algorithmically construct an svg, such as if you're making a chart, you can do that too:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let svg = e::svg()
    .attr(web_str::viewBox(), "-1 -1 2 2")
    .child(e::circle()
        .attr(web_str::cx(), "0")
        .attr(web_str::cy(), "0")
        .attr(web_str::r(), "1")
        .class((
            css::fill::rgba(colors::gray6),
        ))
    );
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-is_dead"><a class="header" href="#async-and-is_dead">Async and .is_dead()</a></h1>
<p>Be careful carelessly accessing entities from an async context. Make sure to check that your entity is still mounted by the time your async computations finish and you're trying to change something.</p>
<pre><code class="language-rust noplaypen">use std::future::Future;

pub fn spawn_complain&lt;T&gt;(x: impl Future&lt;Output = anyhow::Result&lt;T&gt;&gt; + 'static) {
    wasm_bindgen_futures::spawn_local(async move { if let Err(e) = x.await {
        log::error!("{:?}", e);
    }});
}

e::div()
    .tap(move |&amp;element| spawn_complain(async move {
        let value = do_some_request_or_something().await?;
        if element.is_dead() { return Ok(()); }
        element.set_text(value);
        Ok(())
    }))</code></pre>
<p>This isn't necessary outside of async context because wasm is single-threaded so your element can't get unmounted due to user actions, but in some complex scenarios it might be useful anyway. Frequent culprits for issues with this are <code>.child_signal()</code> (which generates a new entity on every signal update) and <code>.replace()</code> (which replaces with a new entity).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hobo-plus"><a class="header" href="#hobo-plus">hobo-plus</a></h1>
<p>It's a crate for random smaller things that don't fit into <code>hobo</code> proper. Currently it exists just as a repository: <a href="https://github.com/zygomedia/hobo-plus">https://github.com/zygomedia/hobo-plus</a></p>
<ul>
<li><code>element_ext::children_diff</code> - currently the "best effort" of making a "list of things that sometimes change" ergonomic in <code>hobo</code>. This construct is easy in VDOM-based frameworks (like React), but challenging otherwise. Ideally, we want to present an interface where the user just provides the data as well as how to convert the data to layout, but not to make the decision about whether to insert/remove/update/reorder existing elements.</li>
<li><code>animation</code> (and <code>animation_with_window</code> for strange use cases) - runs a closure on each animation frame, until the closure returns <code>false</code>. Has been useful on quite a few occasions, but is essentially a gnarly pile of boilerplate <code>web_sys</code>/<code>wasm_bindgen</code> code.</li>
<li><code>svg!</code> - a macro for defining functions for on-disk SVGs to create them as inline SVGs as <code>hobo</code> elements.</li>
<li><code>FileSelect</code> - turns out it's extremely useful (and common) but also extremely annoying to get a file picker in <code>hobo</code> and <code>web_sys</code> in general.</li>
<li><code>entity_ext</code>, <code>element_ext</code> and <code>html_ext</code> - <code>hobo</code>-flavoured extenion traits, that are essentially grab bags of useful methods.</li>
<li><code>socket</code> module - a simple <code>postcard</code>-based socket that buffers messages and automatically reconnects. Likely not useful in all cases, but well suited to how we've been using sockets.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
